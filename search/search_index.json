{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"graphs"},{"location":"/index.html#graphs","text":"graphs is a simple graph library for Scala","title":"graphs"},{"location":"/index.html#example","text":"trait SimpleGraphExample {\n  import com.flowtick.graphs._\n  import com.flowtick.graphs.defaults._\n\n  val graph: Graph[Unit, Unit, String] = Graph.fromEdges(Set(\n    \"A\" --> \"B\",\n    \"B\" --> \"C\",\n    \"D\" --> \"A\"))\n\n  println(graph.edges)\n}","title":"Example"},{"location":"/index.html#documentation","text":"Please check the guide and the API docs","title":"Documentation"},{"location":"/index.html#features","text":"Simple graph creation API Depth-first traversal / search Breadth-first traversal / search Topological sorting Dijkstras algorithm for shortest paths GraphML import / export (experimental) force based layout (planned) cross compiled for Scala 2.12, 2.13, Scala.js","title":"Features"},{"location":"/index.html#motivation","text":"graphs was created to explore different type encoding for graphs and implement well-known algorithms","title":"Motivation"},{"location":"/index.html#goals","text":"Support Scala.js Support GraphML Usages of the library and the core interfaces should be intuitive The codebase should follow current idioms and integrate with mainstream libraries for Scala","title":"Goals"},{"location":"/index.html#non-goals","text":"Support all possible graph types / scenarios Provide a purely functional library","title":"Non-Goals"},{"location":"/index.html#alternatives","text":"Graph for Scala is probably the most established graph library for Scala and supports many kinds of graphs explicitly (custom syntax etc.) with a big variety of algorithms and extensions (json, dot support).\nIts still being worked on and recently added support for Scala.js. It might have a steeper learning curve but is more battle-tested and powerful then graphs.\nquiver follows Martin Erwigs Functions Graph Library and appears to be more or less abandoned. Its less focused on algorithms but provides a more functional perspective on graphs.\ngraphs is inspired and influenced by both libraries. Please check them out to see if they fit your use case and preferences better.","title":"Alternatives"},{"location":"/index.html#license","text":"graphs is published under the terms of the Apache 2.0 License. See the LICENSE file.","title":"License"},{"location":"/setup.html","text":"","title":"Setup"},{"location":"/setup.html#setup","text":"Add the dependency to your build:\nlibraryDependencies += \"com.flowtick\" %% \"graphs-core\" % \"0.3.0\"\nUsing the ammonite REPL you can quickly play around with graphs:\nimport $ivy.`com.flowtick:graphs-core_2.13:0.3.0`\nimport com.flowtick.graphs._\nimport com.flowtick.graphs.defaults._\n\nval graph: Graph[Unit, Unit, String] = Graph.fromEdges(Set(\n  \"A\" --> \"B\",\n  \"B\" --> \"C\",\n  \"D\" --> \"A\"))\n\nprintln(graph.edges)","title":"Setup"},{"location":"/creating-graphs.html","text":"","title":"Creating graphs"},{"location":"/creating-graphs.html#creating-graphs","text":"A graph consists of nodes which represent some objects or values and edges which express a relation between this objects.\ngraphs has a default builder --> that you can use with arbitrary node types. By importing this builder, you can instantly start creating simple graphs:\nimport com.flowtick.graphs._\nimport com.flowtick.graphs.defaults._\n\nval graph: Graph[Unit, Unit, String] = Graph.fromEdges(Set(\n  \"A\" --> \"B\",\n  \"B\" --> \"C\",\n  \"D\" --> \"A\"))\n\nprintln(graph.edges)\nEdges can also have values associated with them, for example a distance between nodes that represent locations.\nNumeric edge values can be used in algorithms like Dijkstras algorithm to find the shortest path between two nodes.\nval cities: Graph[Unit, Int, String] = Graph.fromEdges(Set(\n  \"Frankfurt\" --> (85, \"Mannheim\"),\n  \"Frankfurt\" --> (217, \"Wuerzburg\"),\n  \"Frankfurt\" --> (173, \"Kassel\"),\n  \"Mannheim\" --> (80, \"Karlsruhe\"),\n  \"Wuerzburg\" --> (186, \"Erfurt\"),\n  \"Wuerzburg\" --> (103, \"Nuernberg\"),\n  \"Stuttgart\" --> (183, \"Nuernberg\"),\n  \"Kassel\" --> (502, \"Muenchen\"),\n  \"Nuernberg\" --> (167, \"Muenchen\"),\n  \"Karlsruhe\" --> (250, \"Augsburg\"),\n  \"Augsburg\" --> (84, \"Muenchen\")))","title":"Creating graphs"},{"location":"/creating-graphs.html#core","text":"In graphs the core type is the Graph type.\nIt is parametrized over three types:\nthe value type of the graph meta information (named M) the value type of the edges (named E) the value type of the node (named N)\nThe meta value allows carrying additional information on the graph itself like a description or groups / layers of nodes. In graphs transformations are defined on nodes, which is why the node type is on the right side of the type parameter list.\nA value of a graph instance of type Graph[Unit, Double, String] would be described as\na graph with no meta value and edges of type Double value connecting nodes of type String\nGraph has common methods to work with graph instances:\ntrait Graph[M, E, N] {\n  def meta: M\n  def contexts: scala.collection.Map[N, NodeContext[N, E]]\n  def edges: scala.collection.Set[Edge[E, N]]\n  def nodes: Iterable[N] = contexts.keys\n\n  def findNode(id: N): Option[NodeContext[N, E]] = contexts.get(id)\n\n  def incoming(node: N): Iterable[Edge[E, N]] = contexts.get(node) match {\n    case Some(node) => node.incoming\n    case None => Iterable.empty\n  }\n\n  def outgoing(node: N): Iterable[Edge[E, N]] = contexts.get(node) match {\n    case Some(node) => node.outgoing\n    case None => Iterable.empty\n  }\n\n  def successors(node: N): Iterable[N] = outgoing(node).map(_.to)\n  def predecessors(node: N): Iterable[N] = incoming(node).map(_.from)\n\n  def mapNodes[B](f: N => B): Graph[M, E, B]\n\n  def +(edge: Edge[E, N]): Graph[M, E, N]\n  def withNode(node: N): Graph[M, E, N]\n\n  def withNodes(nodes: Iterable[N]): Graph[M, E, N] = nodes.foldLeft(this)(_ withNode _)\n  def withEdges(edges: Iterable[Edge[E, N]]): Graph[M, E, N] = edges.foldLeft(this)(_ + _)\n  def withMeta[MT](meta: MT): Graph[MT, E, N]\n}","title":"Core"},{"location":"/creating-graphs.html#identity","text":"There is no explicit concept of identity for nodes or edges. It is assumed that the Scala / JVM methods for defining the identity of an object are used. This is mainly important during the creation of a graph, since internally Set and Map implementations are used to manage the relations.\nHowever, for serialization you will need to provide an identity representation via the Identifiable type:\ntrait Identifiable[T, I] {\n  def apply(value: T): I\n}\n\nobject Identifiable {\n  /** creates an instance of [[Identifiable]] using the provided function */\n  def identify[T, I](f: T => I): Identifiable[T, I] = (a: T) => f(a)\n\n  def identity[T]: Identifiable[T, T] = id => id\n}","title":"Identity"},{"location":"/creating-graphs.html#custom-graph-types","text":"Since the graph type itself is parametrized, you can just plug in your types:\nfinal case class MyNode(id: String, someCustomProperty: String)\n\nval graph = Graph.fromEdges(Set(\n  MyNode(\"first_node\", \"My first node\") --> MyNode(\"second_node\", \"My second node\")))\n\nprintln(graph.edges)","title":"Custom Graph Types"},{"location":"/algorithms.html","text":"","title":"Algorithms"},{"location":"/algorithms.html#algorithms","text":"graphs allows ad-hoc extension of graph instances so that you can execute some common operations and algorithms on it.\nCurrently, the following algorithms are supported:","title":"Algorithms"},{"location":"/algorithms.html#depth-first-traversal","text":"A depth first traversal visits every node per branch / path which means that for every node the first child will be visited and the search will be continued there, before going to its siblings.\nEvery node will be visited.\nimport com.flowtick.graphs._\nimport com.flowtick.graphs.algorithm._\nimport com.flowtick.graphs.defaults._\n\ntrait DfsExample {\n  val graph = Graph.fromEdges(Set(\n    \"1\" --> \"2\",\n    \"1\" --> \"9\",\n\n    \"2\" --> \"6\",\n    \"2\" --> \"3\",\n\n    \"3\" --> \"5\",\n    \"3\" --> \"4\",\n\n    \"6\" --> \"7\",\n    \"6\" --> \"8\"))\n\n  println(graph.dfs(\"1\").run)\n  // List(1, 9, 2, 6, 8, 7, 3, 5, 4)\n}","title":"Depth-first traversal"},{"location":"/algorithms.html#breadth-first-traversal","text":"A breadth first traversal visits every node per layer, which means that first all child nodes will be visited before continuing with their children.\nEvery node will be visited.\nimport com.flowtick.graphs._\nimport com.flowtick.graphs.algorithm._\nimport com.flowtick.graphs.defaults._\n\ntrait BfsExample {\n  val graph = Graph.fromEdges(Set(\n    \"A\" --> \"D\",\n    \"A\" --> \"C\",\n    \"A\" --> \"B\",\n    \"B\" --> \"E\",\n    \"B\" --> \"F\",\n    \"B\" --> \"G\",\n    \"E\" --> \"H\"))\n\n  println(graph.bfs(\"A\").run)\n  // List(A, B, C, D, E, F, G, H)\n}","title":"Breadth-first traversal"},{"location":"/algorithms.html#topological-sorting-using-a-depth-first-approach","text":"https://en.wikipedia.org/wiki/Topological_sorting: “topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. For instance, the vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another”\nimport com.flowtick.graphs._\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.algorithm._\n\ntrait TopologicalSortingExample {\n  lazy val graph = Graph.fromEdges(Set(\n    \"A\" --> \"B\",\n    \"B\" --> \"C\",\n    \"D\" --> \"A\"))\n\n  lazy val clothingDependencies = Graph.fromEdges(Set(\n    \"Underpants\" --> \"Pants\",\n    \"Pants\" --> \"Coat\",\n    \"Pullover\" --> \"Coat\",\n    \"Undershirt\" --> \"Pullover\",\n    \"Pants\" --> \"Shoes\",\n    \"Socks\" --> \"Shoes\"))\n\n  println(graph.topologicalSort)\n  // List(D, A, B, C)\n\n  println(clothingDependencies.topologicalSort)\n  // List(Undershirt, Pullover, Underpants, Pants, Coat, Socks, Shoes)\n}","title":"Topological sorting using a depth-first approach"},{"location":"/algorithms.html#dijkstras-algorithm-for-shortest-paths","text":"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm: For a given source node in the graph, the algorithm finds the shortest path between that node and every other. It can also be used for finding the shortest paths from a single node to a single destination node by stopping the algorithm once the shortest path to the destination node has been determined.\nimport com.flowtick.graphs.Graph\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.algorithm._\n\nobject DijkstraGraph {\n  // example taken from https://de.wikipedia.org/wiki/Dijkstra-Algorithmus\n  val cities: Graph[Unit, Int, String] = Graph.fromEdges(Set(\n    \"Frankfurt\" --> (85, \"Mannheim\"),\n    \"Frankfurt\" --> (217, \"Wuerzburg\"),\n    \"Frankfurt\" --> (173, \"Kassel\"),\n    \"Mannheim\" --> (80, \"Karlsruhe\"),\n    \"Wuerzburg\" --> (186, \"Erfurt\"),\n    \"Wuerzburg\" --> (103, \"Nuernberg\"),\n    \"Stuttgart\" --> (183, \"Nuernberg\"),\n    \"Kassel\" --> (502, \"Muenchen\"),\n    \"Nuernberg\" --> (167, \"Muenchen\"),\n    \"Karlsruhe\" --> (250, \"Augsburg\"),\n    \"Augsburg\" --> (84, \"Muenchen\")))\n}\n\ntrait DijkstraExample {\n  println(DijkstraGraph.cities.dijkstra.shortestPath(\"Frankfurt\", \"Muenchen\"))\n  // ListBuffer(Frankfurt --> Wuerzburg[217], Wuerzburg --> Nuernberg[103], Nuernberg --> Muenchen[167])\n}","title":"Dijkstras algorithm for shortest paths"},{"location":"/json.html","text":"","title":"JSON support"},{"location":"/json.html#json-support","text":"graphs supports the serialization of graphs as via circe.\nYou need to add the graphs-json dependency to use it:\nlibraryDependencies += \"com.flowtick\" %% \"graphs-json\" % \"0.3.0\"\nFor the conversion you need to have an Identifiable instance for the node type:","title":"JSON support"},{"location":"/json.html#example-primitive-types-with-defaults","text":"import com.flowtick.graphs._\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.json._\nimport io.circe.generic.auto._\n\nval graph: Graph[Unit, Unit, String] = Graph.fromEdges(Set(\n  \"A\" --> \"D\",\n  \"A\" --> \"C\",\n  \"A\" --> \"B\",\n  \"B\" --> \"E\",\n  \"B\" --> \"F\",\n  \"B\" --> \"G\",\n  \"E\" --> \"H\"))\n\nval json: Json = ToJson(graph)\nval parsed: Either[circe.Error, Graph[Unit, Unit, String]] = FromJson[Unit, Unit, String](json.noSpaces)\n\nrequire(parsed.contains(graph))","title":"Example: primitive types with defaults"},{"location":"/json.html#example-providing-the-id-for-a-custom-type","text":"import com.flowtick.graphs._\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.json._\nimport io.circe.generic.auto._\n\nimport options.unitAsNull\n\ncase class MyNode(id: String, value: Double)\n\nval graph: Graph[Unit, Unit, MyNode] = Graph.fromEdges(Set(\n  MyNode(\"1\", 42) --> MyNode(\"2\", 43)\n))\n\nimplicit val nodeId = Identifiable.identify[MyNode, String](_.id)\n\nval json: Json = ToJson(graph)\nval parsed: Either[circe.Error, Graph[Unit, Unit, MyNode]] = FromJson(json.noSpaces)\n\nrequire(parsed.contains(graph))\nNote that this example is also importing to option to treat unit as null in the JSON representation.","title":"Example: providing the ID for a custom type"},{"location":"/graphml.html","text":"","title":"GraphML support"},{"location":"/graphml.html#graphml-support","text":"graphs supports exporting and loading of graphs to GraphML XML. This format is used by the yed editor, so graphs can be edited and layouted there.\nYou need to add the graphs-graphml dependency to use it:\nlibraryDependencies += \"com.flowtick\" %% \"graphs-graphml\" % \"0.3.0\"","title":"GraphML support"},{"location":"/graphml.html#conversion-to-graphml","text":"This creates a default graph and converts it to a GraphML graph.\nimport com.flowtick.graphs.Graph\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.defaults.label._\nimport com.flowtick.graphs.graphml._\nimport com.flowtick.graphs.graphml.generic._\n\nval simple: Graph[Unit, Unit, String] = Graph.fromEdges(Set(\n  \"A\" --> \"B\",\n  \"B\" --> \"C\",\n  \"D\" --> \"A\"))\n\nval graphML = simple.asGraphML.xml\nval loaded = FromGraphML[Unit, Int, String](graphML.toString)","title":"Conversion to GraphML"},{"location":"/graphml.html#custom-node-types","text":"Its possible to create GraphML graphs directly using the ml edge builder and serialize your own node types, this is implemeted using shapeless:\nimport com.flowtick.graphs.Graph\nimport com.flowtick.graphs.graphml._\nimport com.flowtick.graphs.graphml.generic._\nimport scala.xml.NodeSeq\n\nfinal case class MyNode(value: Int)\n\nval customGraph: Graph[GraphMLGraph[Unit], GraphMLEdge[Unit], GraphMLNode[MyNode]] =\n  GraphML.fromEdges(Set(\n    ml(MyNode(1), id = Some(\"one\")) --> ml(MyNode(2), id = Some(\"two\"))))\n\nval xml: NodeSeq = ToGraphML[Unit, Unit, MyNode](customGraph)\nval loaded = FromGraphML[Unit, Unit, MyNode](xml.toString)","title":"Custom Node Types"},{"location":"/cats.html","text":"","title":"cats support"},{"location":"/cats.html#cats-support","text":"graphs implements some typeclass instances to allow basic operations like combining graphs.\nYou need to add the graphs-cats dependency to use that:\nlibraryDependencies += \"com.flowtick\" %% \"graphs-cats\" % \"0.3.0\"\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.cat.instances._\nimport cats.implicits._\nimport cats.kernel.Monoid\nimport com.flowtick.graphs.Graph\n\ntrait CatsExample {\n  implicit val monoid = Monoid[Graph[Unit, Unit, String]]\n\n  val someGraph: Graph[Unit, Unit, String] = Graph.fromEdges(Set(\n    \"1\" --> \"2\",\n\n    \"2\" --> \"3\",\n    \"2\" --> \"4\"))\n\n  val anotherGraph: Graph[Unit, Unit, String] = Graph.fromEdges(Set(\n    \"2\" --> \"3\",\n\n    \"4\" --> \"3\",\n    \"4\" --> \"5\"))\n\n  val combined: Graph[Unit, Unit, String] = monoid.combine(someGraph, anotherGraph)\n\n  println(combined.edges)\n  // Set(4 --> 3[()], 4 --> 5[()], 1 --> 2[()], 2 --> 3[()], 2 --> 4[()])\n}\nWhich computes the following combination of graphs:","title":"cats support"}]}