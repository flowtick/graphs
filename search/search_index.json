{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"graphs"},{"location":"/index.html#graphs","text":"graphs is simple graph library for Scala and Scala.js","title":"graphs"},{"location":"/index.html#features","text":"Simple graph creation API Depth-first traversal / search Breadth-first traversal / search Topological sorting Dijkstras algorithm for shortest paths GraphML import / export (experimental) force based layout (planned) cross compiled for Scala 2.11, 2.12, Scala.js","title":"Features"},{"location":"/index.html#alternatives","text":"graphs is similar to Graph for Scala but not aiming to model every kind of graph, making the core classes smaller and maybe easier to understand. If you need more than simple directed / undirected graphs please consider using that instead of graphs, be aware that Graph for Scala does not have Scala.js support currently.","title":"Alternatives"},{"location":"/index.html#license","text":"graphs is published under the terms of the Apache 2.0 License. See the LICENSE file.","title":"License"},{"location":"/setup.html","text":"","title":"Setup"},{"location":"/setup.html#setup","text":"Add the dependency to your build:\nlibraryDependencies += \"com.flowtick\" %% \"graphs-core\" % \"0.2.4\"\nUsing the ammonite REPL you can quickly play around with (directed) Graphs:\nimport $ivy.`com.flowtick:graphs-core_2.12:0.2.4`, com.flowtick.graphs.defaults._, com.flowtick.graphs.defaults.directed._ \n\nGraph.from(Seq(n(\"1\") --> n(\"2\")))","title":"Setup"},{"location":"/creating-graphs.html","text":"","title":"Creating graphs"},{"location":"/creating-graphs.html#creating-graphs","text":"A graph consists of nodes which represent some objects or values and edges which express a relation between this objects.\ngraphs has a default implementation of a graph that you can use with arbitrary node types. Using this default implementation, you can instantly start creating simple graphs:\nimport com.flowtick.graphs._\nimport com.flowtick.graphs.defaults._\n\ntrait SimpleGraphExample {\n  val graph = Graph.fromEdges(Set(\n    n(\"A\") --> n(\"B\"),\n    n(\"B\") --> n(\"C\"),\n    n(\"D\") --> n(\"A\")))\n\n  println(graph.edges)\n  // Set(A --> B[()], B --> C[()], D --> A[()])\n}\nEdges can also have values associated with them, for example a distance between nodes that represent locations.\nNumeric edge values can be used in algorithms like Dijkstras algorithm to find the shortest path between two nodes.\nval cities: Graph[Int, String, Unit] = Graph.fromEdges(Set(\n  n(\"Frankfurt\") --> (85, n(\"Mannheim\")),\n  n(\"Frankfurt\") --> (217, n(\"Wuerzburg\")),\n  n(\"Frankfurt\") --> (173, n(\"Kassel\")),\n  n(\"Mannheim\") --> (80, n(\"Karlsruhe\")),\n  n(\"Wuerzburg\") --> (186, n(\"Erfurt\")),\n  n(\"Wuerzburg\") --> (103, n(\"Nuernberg\")),\n  n(\"Stuttgart\") --> (183, n(\"Nuernberg\")),\n  n(\"Kassel\") --> (502, n(\"Muenchen\")),\n  n(\"Nuernberg\") --> (167, n(\"Muenchen\")),\n  n(\"Karlsruhe\") --> (250, n(\"Augsburg\")),\n  n(\"Augsburg\") --> (84, n(\"Muenchen\"))))","title":"Creating graphs"},{"location":"/creating-graphs.html#core-types","text":"In graphs the core type is the Graph type-class:\ntrait Graph[V, N, M] {\n  def value: M\n\n  def nodeContext: scala.collection.Map[N, NodeContext[V, N]]\n\n  def nodes: Iterable[N]\n\n  def edges: Iterable[Edge[V, N]]\n\n  def outgoing(node: N): Set[Edge[V, N]]\n\n  def incoming(node: N): Set[Edge[V, N]]\n\n  def predecessors(node: N): Iterator[N]\n\n  def successors(node: N): Iterator[N]\n}\n\nabstract class GraphBase[V, N, M] extends Graph[V, N, M] {\n  private lazy val lazyNodes: Iterable[N] = nodeContext.keys\n\n  /**\n   * TODO (maybe) this could be optimized, in a graph were everything points to one node\n   * this would iterate still everything\n   */\n  private lazy val lazyEdges: Iterable[Edge[V, N]] = nodeContext.iterator.flatMap {\n    case (_, context) => context.incoming.iterator\n  }.toIterable\n\n  def nodes: Iterable[N] = lazyNodes\n\n  def edges: Iterable[Edge[V, N]] = lazyEdges\n\n  def outgoing(node: N): Set[Edge[V, N]] = nodeContext.get(node).map(_.outgoing).getOrElse(Set.empty)\n\n  def incoming(node: N): Set[Edge[V, N]] = nodeContext.get(node).map(_.incoming).getOrElse(Set.empty)\n\n  def predecessors(node: N): Iterator[N] = incoming(node).iterator.map(_.head)\n\n  def successors(node: N): Iterator[N] = outgoing(node).iterator.map(_.tail)\n}\nYou can see that is a type constructor with a higher-kinded type G for a graph type that has 3 holes (type parameters) in it: G[_, _, _] .\nThis allows to parametrize the graphs:\nby the value type of the edges (usually named V) by the value type of the node (usually named N) by the value type of the graph (usually named M)\nThe later allows to carry some meta information like a description or groups / layers of nodes.\nIn the methods of the type class you see how the type parameters are applied to the type constructors: G[V, N, M] which can be read as a graph with value M and edge values V connecting nodes of type N.","title":"Core Types"},{"location":"/creating-graphs.html#custom-graph-types","text":"Since the graph type itself is parametrized, you can just plug in your types:\nfinal case class MyNode(id: String, someCustomProperty: String)\n\nval graph = Graph.fromEdges(Set(\n  n(MyNode(\"first_node\", \"My first node\")) --> n(MyNode(\"second_node\", \"My second node\"))))\n\nprintln(graph.edges)\n// Set(MyNode(first_node,My first node) --> MyNode(second_node,My second node)[()])","title":"Custom Graph Types"},{"location":"/creating-graphs.html#default-graph","text":"If you want to change the graph type itself for some reason, you should look at the default graph implementation, which shows a complete example on how to implement the type class instances:\npackage com.flowtick.graphs\n\npackage object defaults {\n  def n[X](value: X, label: Option[String] = None) = Node[X](value, label)\n\n  implicit val identifiableUnit: Identifiable[Unit] = new Identifiable[Unit] {\n    override def id(string: Unit): String = \"()\"\n  }\n\n  implicit val identifiableString: Identifiable[String] = new Identifiable[String] {\n    override def id(string: String): String = string\n  }\n\n  implicit def identifiableNumeric[N](implicit numeric: Numeric[N]): Identifiable[N] = new Identifiable[N] {\n    override def id(number: N): String = numeric.toDouble(number).toString\n  }\n\n  implicit val unitLabel: Labeled[Unit, String] = new Labeled[Unit, String] {\n    override def label(edge: Unit): Option[String] = None\n  }\n\n  implicit val stringLabel: Labeled[String, String] = new Labeled[String, String] {\n    override def label(string: String): Option[String] = Some(string)\n  }\n\n  implicit def numericLabel[T](implicit numeric: Numeric[T]): Labeled[T, String] = new Labeled[T, String] {\n    override def label(number: T): Option[String] = Some(numeric.toDouble(number).toString)\n  }\n\n  implicit def labeledEdge[V, N](implicit labeled: Labeled[V, String]): Labeled[Edge[V, N], String] = new Labeled[Edge[V, N], String] {\n    override def label(e: Edge[V, N]): Option[String] = labeled.label(e.value)\n  }\n\n  implicit class DefaultEdgeBuilder[X](node: Node[X]) {\n    def -->[V](value: V, to: Node[X]): Edge[V, X] = Edge[V, X](value, node.value, to.value)\n    def -->(to: Node[X]): Edge[Unit, X] = Edge[Unit, X]((), node.value, to.value)\n  }\n}","title":"Default Graph"},{"location":"/algorithms.html","text":"","title":"Algorithms"},{"location":"/algorithms.html#algorithms","text":"graphs allows ad-hoc extension of graph instances so that you can execute some common operations and algorithms on it.\nCurrently the following algorithms are supported:","title":"Algorithms"},{"location":"/algorithms.html#depth-first-traversal","text":"A depth first traversal visits every node per branch / path which means that for every node the first child will be visited and the search will be continued there, before going to its siblings.\nEvery node will be visited.\nimport com.flowtick.graphs._\nimport com.flowtick.graphs.algorithm._\nimport com.flowtick.graphs.defaults._\n\ntrait DfsExample {\n  val graph = Graph.fromEdges(Set(\n    n(\"1\") --> n(\"2\"),\n    n(\"1\") --> n(\"9\"),\n\n    n(\"2\") --> n(\"6\"),\n    n(\"2\") --> n(\"3\"),\n\n    n(\"3\") --> n(\"5\"),\n    n(\"3\") --> n(\"4\"),\n\n    n(\"6\") --> n(\"7\"),\n    n(\"6\") --> n(\"8\")))\n\n  println(graph.dfs(\"1\").run)\n  // List(1, 9, 2, 6, 8, 7, 3, 5, 4)\n}","title":"Depth-first traversal"},{"location":"/algorithms.html#breadth-first-traversal","text":"A breadth first traversal visits every node per layer, which means that first all child nodes will be visited before continuing with their children.\nEvery node will be visited.\nimport com.flowtick.graphs._\nimport com.flowtick.graphs.algorithm._\nimport com.flowtick.graphs.defaults._\n\ntrait BfsExample {\n  val graph = Graph.fromEdges(Set(\n    n(\"A\") --> n(\"D\"),\n    n(\"A\") --> n(\"C\"),\n    n(\"A\") --> n(\"B\"),\n    n(\"B\") --> n(\"E\"),\n    n(\"B\") --> n(\"F\"),\n    n(\"B\") --> n(\"G\"),\n    n(\"E\") --> n(\"H\")))\n\n  println(graph.bfs(\"A\").run)\n  // List(A, B, C, D, E, F, G, H)\n}","title":"Breadth-first traversal"},{"location":"/algorithms.html#topological-sorting-using-a-depth-first-approach","text":"https://en.wikipedia.org/wiki/Topological_sorting: “topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. For instance, the vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another”\nimport com.flowtick.graphs._\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.algorithm._\n\ntrait TopologicalSortingExample {\n  lazy val graph = Graph.fromEdges(Set(\n    n(\"A\") --> n(\"B\"),\n    n(\"B\") --> n(\"C\"),\n    n(\"D\") --> n(\"A\")))\n\n  lazy val clothingDependencies = Graph.fromEdges(Set(\n    n(\"Underpants\") --> n(\"Pants\"),\n    n(\"Pants\") --> n(\"Coat\"),\n    n(\"Pullover\") --> n(\"Coat\"),\n    n(\"Undershirt\") --> n(\"Pullover\"),\n    n(\"Pants\") --> n(\"Shoes\"),\n    n(\"Socks\") --> n(\"Shoes\")))\n\n  println(graph.topologicalSort)\n  // List(D, A, B, C)\n\n  println(clothingDependencies.topologicalSort)\n  // List(Undershirt, Pullover, Underpants, Pants, Coat, Socks, Shoes)\n}","title":"Topological sorting using a depth-first approach"},{"location":"/algorithms.html#dijkstras-algorithm-for-shortest-paths","text":"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm: For a given source node in the graph, the algorithm finds the shortest path between that node and every other. It can also be used for finding the shortest paths from a single node to a single destination node by stopping the algorithm once the shortest path to the destination node has been determined.\nimport com.flowtick.graphs.Graph\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.algorithm._\n\nobject DijkstraGraph {\n  // example taken from https://de.wikipedia.org/wiki/Dijkstra-Algorithmus\n  val cities: Graph[Int, String, Unit] = Graph.fromEdges(Set(\n    n(\"Frankfurt\") --> (85, n(\"Mannheim\")),\n    n(\"Frankfurt\") --> (217, n(\"Wuerzburg\")),\n    n(\"Frankfurt\") --> (173, n(\"Kassel\")),\n    n(\"Mannheim\") --> (80, n(\"Karlsruhe\")),\n    n(\"Wuerzburg\") --> (186, n(\"Erfurt\")),\n    n(\"Wuerzburg\") --> (103, n(\"Nuernberg\")),\n    n(\"Stuttgart\") --> (183, n(\"Nuernberg\")),\n    n(\"Kassel\") --> (502, n(\"Muenchen\")),\n    n(\"Nuernberg\") --> (167, n(\"Muenchen\")),\n    n(\"Karlsruhe\") --> (250, n(\"Augsburg\")),\n    n(\"Augsburg\") --> (84, n(\"Muenchen\"))))\n}\n\ntrait DijkstraExample {\n  println(DijkstraGraph.cities.shortestPath(\"Frankfurt\", \"Muenchen\"))\n  // ListBuffer(Frankfurt --> Wuerzburg[217], Wuerzburg --> Nuernberg[103], Nuernberg --> Muenchen[167])\n}","title":"Dijkstras algorithm for shortest paths"},{"location":"/graphml.html","text":"","title":"GraphML support"},{"location":"/graphml.html#graphml-support","text":"graphs supports rendering and loading (currently only on the JVM) of graphs to GraphML XML.\nYou need to add the graphs-graphml dependency to use that:\nlibraryDependencies += \"com.flowtick\" %% \"graphs-graphml\" % \"0.2.4\"\nimport com.flowtick.graphs.Graph\n\ntrait GraphMLExample {\n  {\n    import com.flowtick.graphs.defaults._\n    import com.flowtick.graphs.graphml._\n    val graphMLCities: Graph[GraphMLEdge[Int], GraphMLNode[String], GraphMLGraph[Unit]] = DijkstraGraph.cities.toGraphML()\n\n    println(fromGraphML[Int, String, Unit](graphMLCities.xml.toString()))\n    println(graphMLCities)\n    // ImmutableGraph(GraphMLGraph((),Some(G),List()),Map(GraphMLNode(Erfurt,Erfurt, ...\n  }\n\n  {\n    import com.flowtick.graphs.defaults._\n    import com.flowtick.graphs.graphml._\n    val graph = Graph.fromEdges[Unit, String](Set(n(\"A\") --> n(\"B\")))\n    val xml = graph.toGraphML().xml\n    println(fromGraphML[Unit, String, Unit](xml.toString))\n  }\n}\nThis format is used by the yed editor, so graphs can be edited and layouted there.","title":"GraphML support"},{"location":"/cats.html","text":"","title":"cats support"},{"location":"/cats.html#cats-support","text":"graphs implements some typeclass instances to allow basic operations like combining graphs.\nYou need to add the graphs-cats dependency to use that:\nlibraryDependencies += \"com.flowtick\" %% \"graphs-cats\" % \"0.2.4\"\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.cat.instances._\nimport cats.implicits._\nimport cats.kernel.Monoid\nimport com.flowtick.graphs.Graph\n\ntrait CatsExample {\n  implicit val monoid = Monoid[Graph[Unit, String, Unit]]\n\n  val someGraph: Graph[Unit, String, Unit] = Graph.fromEdges(Set(\n    n(\"1\") --> n(\"2\"),\n\n    n(\"2\") --> n(\"3\"),\n    n(\"2\") --> n(\"4\")))\n\n  val anotherGraph: Graph[Unit, String, Unit] = Graph.fromEdges(Set(\n    n(\"2\") --> n(\"3\"),\n\n    n(\"4\") --> n(\"3\"),\n    n(\"4\") --> n(\"5\")))\n\n  val combined: Graph[Unit, String, Unit] = monoid.combine(someGraph, anotherGraph)\n\n  println(combined.edges)\n  // Set(4 --> 3[()], 4 --> 5[()], 1 --> 2[()], 2 --> 3[()], 2 --> 4[()])\n}\nWhich computes the following combination of graphs:","title":"cats support"}]}