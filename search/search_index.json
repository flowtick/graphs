{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"graphs"},{"location":"/index.html#graphs","text":"graphs is simple graph library for Scala and Scala.js","title":"graphs"},{"location":"/index.html#features","text":"Simple graph creation API Depth-first traversal / search Breadth-first traversal / search Topological sorting Dijkstras algorithm for shortest paths GraphML import / export (experimental) force based layout (planned) cross compiled for Scala 2.11, 2.12, Scala.js","title":"Features"},{"location":"/index.html#alternatives","text":"graphs is similar to Graph for Scala but not aiming to model every kind of graph, making the core classes smaller and maybe easier to understand. If you need more than simple directed / undirected graphs please consider using that instead of graphs, be aware that Graph for Scala does not have Scala.js support currently.","title":"Alternatives"},{"location":"/index.html#license","text":"graphs is published under the terms of the Apache 2.0 License. See the LICENSE file.","title":"License"},{"location":"/setup.html","text":"","title":"Setup"},{"location":"/setup.html#setup","text":"Add the dependency to your build:\nlibraryDependencies += \"com.flowtick\" %% \"graphs-core\" % \"0.2.2\"\nUsing the ammonite REPL you can quickly play around with (directed) Graphs:\nimport $ivy.`com.flowtick:graphs-core_2.12:0.2.2`, com.flowtick.graphs.defaults._, com.flowtick.graphs.defaults.directed._ \n\ndefaultGraph.from(Seq(n(\"1\") --> n(\"2\")))","title":"Setup"},{"location":"/creating-graphs.html","text":"","title":"Creating graphs"},{"location":"/creating-graphs.html#creating-graphs","text":"A graph consists of nodes which represent some objects or values and edges which express a relation between this objects.\ngraphs has a default implementation of a graph that you can use with arbitrary node types. Using this default implementation, you can instantly start creating simple graphs:\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.defaults.directed._\n\nobject SimpleGraphApp extends App {\n  val graph = defaultGraph.from(Set(\n    n(\"A\") --> n(\"B\"),\n    n(\"B\") --> n(\"C\"),\n    n(\"D\") --> n(\"A\")))\n\n  println(defaultGraph.edges(graph))\n  // Set(A --> B[()], B --> C[()], D --> A[()])\n}\nEdges can also have values associated with them, for example a distance between nodes that represent locations.\nNumeric edge values can be used in algorithms like Dijkstras algorithm to find the shortest path between two nodes.\nval cities = defaultGraph.from(Set(\n  n(\"Frankfurt\") --> (85, n(\"Mannheim\")),\n  n(\"Frankfurt\") --> (217, n(\"Wuerzburg\")),\n  n(\"Frankfurt\") --> (173, n(\"Kassel\")),\n  n(\"Mannheim\") --> (80, n(\"Karlsruhe\")),\n  n(\"Wuerzburg\") --> (186, n(\"Erfurt\")),\n  n(\"Wuerzburg\") --> (103, n(\"Nuernberg\")),\n  n(\"Stuttgart\") --> (183, n(\"Nuernberg\")),\n  n(\"Kassel\") --> (502, n(\"Muenchen\")),\n  n(\"Nuernberg\") --> (167, n(\"Muenchen\")),\n  n(\"Karlsruhe\") --> (250, n(\"Augsburg\")),\n  n(\"Augsburg\") --> (84, n(\"Muenchen\"))))","title":"Creating graphs"},{"location":"/creating-graphs.html#core-types","text":"In graphs the core type is the graph type-class:\ntrait Graph[G[_, _, _], ET[_, _]] {\n  def value[V, N, M](graph: G[ET[V, N], N, M]): M\n\n  def edges[V, N, M](graph: G[ET[V, N], N, M])(implicit edgeType: EdgeType[ET]): Iterable[ET[V, N]]\n\n  def nodes[V, N, M](graph: G[ET[V, N], N, M])(implicit edgeType: EdgeType[ET]): Iterable[N]\n\n  def incoming[V, N, M](graph: G[ET[V, N], N, M])(implicit edgeType: EdgeType[ET]): scala.collection.Map[N, Iterable[ET[V, N]]]\n\n  def outgoing[V, N, M](graph: G[ET[V, N], N, M])(implicit edgeType: EdgeType[ET]): scala.collection.Map[N, Iterable[ET[V, N]]]\n\n  def predecessors[V, N, M](node: N, graph: G[ET[V, N], N, M])(implicit edgeType: EdgeType[ET]): Iterable[N] =\n    incoming(graph).getOrElse(node, Iterable.empty).map(edgeType.head)\n\n  def successors[V, N, M](node: N, graph: G[ET[V, N], N, M])(implicit edgeType: EdgeType[ET]): Iterable[N] =\n    outgoing(graph).getOrElse(node, Iterable.empty).map(edgeType.tail)\n}\nYou can see that is a type constructor with a higher-kinded type G for a graph type that has 3 holes (type parameters) in it: G[_, _, _] and a second higher-kinded type with 2 parameters: ET[_, _] which is the edge type.\nThis allows to parametrize the graphs:\nby the edge type which defines the relation between nodes by the value type of the edges by the value type of the node by the value type of the graph (to allow carry it some meta information like a description or groups of nodes)\nThe edge type is parametrized by the edge value type and the node value type.\nIn the methods of the type-class you see how the type parameters are applied to the type constructors: G[ET[V, N], N, M] which can be read as a graph with value M and edge type ET of edge values V connecting nodes of type N.","title":"Core Types"},{"location":"/creating-graphs.html#custom-graph-types","text":"Since the graph type itself is parametrized, you can just plug in your types. You only need to define how nodes can be identified:\ncase class MyNode(id: String, someCustomProperty: String)\n\nimplicit def identifiableNode = new Identifiable[MyNode] {\n  override def id(node: MyNode): String = node.id\n}\n\nval graph = defaultGraph.from(Set(\n  n(MyNode(\"first_node\", \"My first node\")) --> n(MyNode(\"second_node\", \"My second node\"))))\n\nprintln(defaultGraph.edges(graph))\n// Set(MyNode(first_node,My first node) --> MyNode(second_node,My second node)[()])","title":"Custom Graph Types"},{"location":"/creating-graphs.html#default-graph","text":"If you want to change the graph type itself for some reason, you should look at the default graph implementation, which shows a complete example on how to implement the type class instances:\npackage com.flowtick.graphs\n\npackage object defaults {\n  final case class Node[X](value: X, label: Option[String] = None)(implicit identifiable: Identifiable[X]) {\n    def id: String = identifiable.id(value)\n    override def toString: String = s\"$id${label.map(\" (\" + _ + \")\").getOrElse(\"\")}\"\n  }\n\n  /**\n   * case class holding the values of a default graph\n   *\n   * the fields are private since we want the type class instance to be used for access\n   *\n   * @param edges\n   * @param nodes\n   * @param incoming\n   * @param outgoing\n   * @tparam E\n   * @tparam N\n   */\n  final case class DefaultGraph[E, N, M](\n    private[defaults] val value: M,\n    private[defaults] val edges: Iterable[E],\n    private[defaults] val nodes: Iterable[N],\n    private[defaults] val incoming: scala.collection.Map[N, Iterable[E]],\n    private[defaults] val outgoing: scala.collection.Map[N, Iterable[E]])\n\n  final case class Edge[V, N](value: V, head: N, tail: N) {\n    override def toString: String = s\"$head --> $tail[$value]\"\n  }\n\n  implicit def defaultGraph[G[_, _, _], ET[_, _]]: Graph[DefaultGraph, ET] with GraphBuilder[DefaultGraph, ET] = new Graph[DefaultGraph, ET] with GraphBuilder[DefaultGraph, ET] {\n    override def edges[V, N, M](graph: DefaultGraph[ET[V, N], N, M])(implicit edgeType: EdgeType[ET]): Iterable[ET[V, N]] =\n      graph.edges\n\n    override def incoming[V, N, M](\n      graph: DefaultGraph[ET[V, N], N, M])(implicit edgeType: EdgeType[ET]): scala.collection.Map[N, Iterable[ET[V, N]]] =\n      graph.incoming\n\n    override def outgoing[V, N, M](\n      graph: DefaultGraph[ET[V, N], N, M])(implicit edgeType: EdgeType[ET]): scala.collection.Map[N, Iterable[ET[V, N]]] =\n      graph.outgoing\n\n    override def nodes[V, N, M](graph: DefaultGraph[ET[V, N], N, M])(implicit edgeType: EdgeType[ET]): Iterable[N] =\n      graph.nodes\n\n    override def build[V, N, M](\n      value: M,\n      edges: Iterable[ET[V, N]],\n      nodes: Iterable[N],\n      incoming: scala.collection.Map[N, Iterable[ET[V, N]]],\n      outgoing: scala.collection.Map[N, Iterable[ET[V, N]]]): DefaultGraph[ET[V, N], N, M] = DefaultGraph(value, edges, nodes, incoming, outgoing)\n\n    override def value[V, N, M](graph: DefaultGraph[ET[V, N], N, M]): M = graph.value\n  }\n\n\n  def n[X](value: X, label: Option[String] = None)(implicit identifiable: Identifiable[X]) = Node[X](value, None)\n\n  implicit def identifiableNode[X]: Identifiable[Node[X]] = new Identifiable[Node[X]] {\n    override def id(node: Node[X]): String = node.id\n  }\n\n  implicit def identifiableString[X]: Identifiable[String] = new Identifiable[String] {\n    override def id(string: String): String = string\n  }\n\n  implicit def identifiableNumeric[N](implicit numeric: Numeric[N]): Identifiable[N] = new Identifiable[N] {\n    override def id(number: N): String = numeric.toDouble(number).toString\n  }\n\n  implicit def unitLabel: Labeled[Unit, String] = new Labeled[Unit, String] {\n    override def label(edge: Unit): Option[String] = None\n  }\n\n  implicit def stringLabel: Labeled[String, String] = new Labeled[String, String] {\n    override def label(string: String): Option[String] = Some(string)\n  }\n\n  implicit def numericLabel[T](implicit numeric: Numeric[T]): Labeled[T, String] = new Labeled[T, String] {\n    override def label(number: T): Option[String] = Some(numeric.toDouble(number).toString)\n  }\n\n  implicit def labeledEdge[E[_, _], V, N](implicit edge: EdgeType[E], labeled: Labeled[V, String]): Labeled[E[V, N], String] = new Labeled[E[V, N], String] {\n    override def label(e: E[V, N]): Option[String] = labeled.label(edge.value(e))\n  }\n\n  implicit def emptyUnit: Empty[Unit] = new Empty[Unit] {\n    override def empty: Unit = ()\n  }\n\n  implicit def emptyOption[T]: Empty[Option[T]] = new Empty[Option[T]] {\n    override def empty: Option[T] = None\n  }\n\n  object directed {\n    implicit def edge: EdgeType[Edge] = new EdgeType[Edge] {\n      override def apply[V, N](\n        value: V,\n        head: N,\n        tail: N): Edge[V, N] = Edge(value, head, tail)\n\n      override def value[V, N](edge: Edge[V, N]): V = edge.value\n\n      override def head[V, N](edge: Edge[V, N]): N = edge.head\n      override def tail[V, N](edge: Edge[V, N]): N = edge.tail\n    }\n\n    implicit class DirectedEdgeBuilder[X](node: Node[X]) {\n      def -->[V](value: V, to: Node[X]): Edge[V, X] = Edge[V, X](value, node.value, to.value)\n      def -->[V](to: Node[X]): Edge[Unit, X] = Edge[Unit, X]((), node.value, to.value)\n    }\n  }\n\n}","title":"Default Graph"},{"location":"/algorithms.html","text":"","title":"Algorithms"},{"location":"/algorithms.html#algorithms","text":"graphs allows ad-hoc extension of graph instances so that you can execute some common operations and algorithms on it.\nCurrently the following algorithms are supported:","title":"Algorithms"},{"location":"/algorithms.html#depth-first-traversal","text":"A depth first traversal visits every node per branch / path which means that for every node the first child will be visited and the search will be continued there, before going to its siblings.\nEvery node will be visited.\nimport com.flowtick.graphs.algorithm._\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.defaults.directed._\n\nobject DfsApp extends App {\n  val graph = defaultGraph.from(Set(\n    n(\"1\") --> n(\"2\"),\n    n(\"1\") --> n(\"9\"),\n\n    n(\"2\") --> n(\"6\"),\n    n(\"2\") --> n(\"3\"),\n\n    n(\"3\") --> n(\"5\"),\n    n(\"3\") --> n(\"4\"),\n\n    n(\"6\") --> n(\"7\"),\n    n(\"6\") --> n(\"8\")))\n\n  println(graph.dfs(\"1\").run)\n  // List(1, 9, 2, 6, 8, 7, 3, 5, 4)\n}","title":"Depth-first traversal"},{"location":"/algorithms.html#breadth-first-traversal","text":"A breadth first traversal visits every node per layer, which means that first all child nodes will be visited before continuing with their children.\nEvery node will be visited.\nimport com.flowtick.graphs.algorithm._\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.defaults.directed._\n\nobject BfsApp extends App {\n  val graph = defaultGraph.from(Set(\n    n(\"A\") --> n(\"D\"),\n    n(\"A\") --> n(\"C\"),\n    n(\"A\") --> n(\"B\"),\n    n(\"B\") --> n(\"E\"),\n    n(\"B\") --> n(\"F\"),\n    n(\"B\") --> n(\"G\"),\n    n(\"E\") --> n(\"H\")))\n\n  println(graph.bfs(\"A\").run)\n  // List(A, B, C, D, E, F, G, H)\n}","title":"Breadth-first traversal"},{"location":"/algorithms.html#topological-sorting-using-a-depth-first-approach","text":"https://en.wikipedia.org/wiki/Topological_sorting: “topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. For instance, the vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another”\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.defaults.directed._\nimport com.flowtick.graphs.algorithm._\n\nobject TopologicalSortingApp extends App {\n  lazy val graph = defaultGraph.from(Set(\n    n(\"A\") --> n(\"B\"),\n    n(\"B\") --> n(\"C\"),\n    n(\"D\") --> n(\"A\")))\n\n  lazy val clothingDependencies = defaultGraph.from(Set(\n    n(\"Underpants\") --> n(\"Pants\"),\n    n(\"Pants\") --> n(\"Coat\"),\n    n(\"Pullover\") --> n(\"Coat\"),\n    n(\"Undershirt\") --> n(\"Pullover\"),\n    n(\"Pants\") --> n(\"Shoes\"),\n    n(\"Socks\") --> n(\"Shoes\")))\n\n  println(graph.topologicalSort)\n  // List(D, A, B, C)\n\n  println(clothingDependencies.topologicalSort)\n  // List(Undershirt, Pullover, Underpants, Pants, Coat, Socks, Shoes)\n}","title":"Topological sorting using a depth-first approach"},{"location":"/algorithms.html#dijkstras-algorithm-for-shortest-paths","text":"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm: For a given source node in the graph, the algorithm finds the shortest path between that node and every other. It can also be used for finding the shortest paths from a single node to a single destination node by stopping the algorithm once the shortest path to the destination node has been determined.\nimport com.flowtick.graphs.algorithm._\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.defaults.directed._\n\nobject DijkstraGraph {\n  // example taken from https://de.wikipedia.org/wiki/Dijkstra-Algorithmus\n  val cities = defaultGraph.from(Set(\n    n(\"Frankfurt\") --> (85, n(\"Mannheim\")),\n    n(\"Frankfurt\") --> (217, n(\"Wuerzburg\")),\n    n(\"Frankfurt\") --> (173, n(\"Kassel\")),\n    n(\"Mannheim\") --> (80, n(\"Karlsruhe\")),\n    n(\"Wuerzburg\") --> (186, n(\"Erfurt\")),\n    n(\"Wuerzburg\") --> (103, n(\"Nuernberg\")),\n    n(\"Stuttgart\") --> (183, n(\"Nuernberg\")),\n    n(\"Kassel\") --> (502, n(\"Muenchen\")),\n    n(\"Nuernberg\") --> (167, n(\"Muenchen\")),\n    n(\"Karlsruhe\") --> (250, n(\"Augsburg\")),\n    n(\"Augsburg\") --> (84, n(\"Muenchen\"))))\n}\n\nobject DijkstraApp extends App {\n  println(DijkstraGraph.cities.shortestPath(\"Frankfurt\", \"Muenchen\"))\n  // ListBuffer(Frankfurt --> Wuerzburg[217], Wuerzburg --> Nuernberg[103], Nuernberg --> Muenchen[167])\n}","title":"Dijkstras algorithm for shortest paths"},{"location":"/graphml.html","text":"","title":"GraphML support"},{"location":"/graphml.html#graphml-support","text":"graphs supports rendering and loading (currently only on the JVM) of graphs to GraphML XML.\nYou need to add the graphs-graphml dependency to use that:\nlibraryDependencies += \"com.flowtick\" %% \"graphs-graphml\" % \"0.2.2\"\nimport java.io.FileOutputStream\n\nimport com.flowtick.graphs.{ EdgeType, Graph, Identifiable, Labeled }\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.defaults.directed._\nimport com.flowtick.graphs.graphml.{ GraphMLImporter, GraphMLRenderer }\nimport com.flowtick.graphs.layout.{ JGraphXLayouter, ShapeDefinition }\n\nobject GraphMLRendererApp extends App {\n  def writeGraphXML[G[_, _, _], E[_, _], V, N, M](g: G[E[V, N], N, M], fileName: String)(implicit graph: Graph[G, E], edgeType: EdgeType[E], identifiable: Identifiable[N], edgeLabel: Labeled[E[V, N], String]): String = {\n    val graphXml = new GraphMLRenderer().render[G, E, V, N, M](\n      g,\n      JGraphXLayouter,\n      (_: N) => Some(ShapeDefinition(rounded = true, color = \"#AAAAAA\")))\n\n    val output = new FileOutputStream(fileName)\n    output.write(graphXml.toString().getBytes)\n    output.flush()\n    output.close()\n\n    graphXml.toString()\n  }\n\n  val writtenXml = writeGraphXML(DijkstraGraph.cities, \"target/cities.graphml\")\n  println(new GraphMLImporter[DefaultGraph, Edge]().fromXml(writtenXml))\n  // Right(DefaultGraph(GraphMLGraph(Some(G)),ListBuffer(GraphMLNode(Frankfurt,Some(Frankfurt),Map(graphics -> ...\n}\nThis format is used by the yed editor, so graphs can be edited and layouted there.","title":"GraphML support"},{"location":"/cats.html","text":"","title":"cats support"},{"location":"/cats.html#cats-support","text":"graphs implements some typeclass instances to allow basic operations like combining graphs.\nYou need to add the graphs-cats dependency to use that:\nlibraryDependencies += \"com.flowtick\" %% \"graphs-cats\" % \"0.2.2\"\nimport com.flowtick.graphs.defaults._\nimport com.flowtick.graphs.defaults.directed._\nimport com.flowtick.graphs.cat._\nimport cats.implicits._\nimport cats.kernel.Monoid\n\nobject CatsApp extends App {\n  implicit val monoid: Monoid[DefaultGraph[Edge[Unit, String], String, Unit]] = graphMonoid\n\n  val someGraph = defaultGraph.from(Set(\n    n(\"1\") --> n(\"2\"),\n\n    n(\"2\") --> n(\"3\"),\n    n(\"2\") --> n(\"4\")))\n\n  val anotherGraph = defaultGraph.from(Set(\n    n(\"2\") --> n(\"3\"),\n\n    n(\"4\") --> n(\"3\"),\n    n(\"4\") --> n(\"5\")))\n\n  val combined = monoid.combine(someGraph, anotherGraph)\n\n  println(defaultGraph.edges(combined))\n  // Set(4 --> 3[()], 4 --> 5[()], 1 --> 2[()], 2 --> 3[()], 2 --> 4[()])\n}\nWhich computes the following combination of graphs:","title":"cats support"}]}